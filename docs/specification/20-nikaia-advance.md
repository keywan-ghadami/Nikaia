# Nikaia Language Specification
**Part II: Advanced Features & Metaprogramming**
**Version:** 0.0.5 (Draft)
**Date:** January 22, 2026

---

## Chapter 10: Metaprogramming (Code that writes Code)

Metaprogramming allows developers to extend the language itself. In Nikaia, this is not done with text replacements (like in C) but by manipulating the structure of the code (the **AST** or Abstract Syntax Tree) in a safe way.

### 10.1. Parsing with `grammar`
Before you can manipulate code, you often need to read custom data formats. The `grammar` tool allows you to write parsers easily.

```nika
// Defines a parser that turns strings like "#FF0000" into a Color struct
grammar ColorParser {
    option recursion_limit = 50;

    pub rule entry -> Color = {
        "#" r:hex() g:hex() b:hex()
    } -> {
        Color { r, g, b }
    }
    
    rule hex -> u8 = s:regex("[0-9A-Fa-f]{2}") -> { 
        u8::from_str_radix(s, 16)? 
    }
}
```

### 10.2. Dual-Mode Parsing (Static vs. Dynamic)
One of Nikaia's most powerful features is that a grammar defined once can be used in two completely different ways.

**A. Static Embedding (Compile-Time)**
You can use a parser to read files *during the build process*. If the file contains a syntax error, the compilation fails. The result is embedded into the final binary as a constant, with zero runtime cost.

```nika
// Reads "theme.conf" at compile time.
// The compiler executes ColorParser. If the file is invalid, the build stops.
const THEME: Color = from "theme.conf" with ColorParser
```

**B. Dynamic Parsing (Runtime)**
You can use the exact same parser to process user input or network data while the program is running.

```nika
fn update_color(input: String) throws ParseError {
    // The ::parse method is automatically generated for every grammar.
    let color = ColorParser::parse(input)?
    println("New Color: {color.r}, {color.g}, {color.b}")
}
```

### 10.3. Code Generation (Quasi-Quoting)
While parsing reads data, **Macros** create new code. Nikaia uses a mechanism called **Quasi-Quoting**. The `quote` block allows you to write Nikaia code as data templates and fill in the blanks with variables.

**Example: Auto-Generating a "Describe" Function**
Imagine you want to automatically print all fields of a struct without writing the print statements manually every time.

```nika
// Definition of the Macro
pub macro Describe(def: StructDef) -> AstExpr {
    
    // Logic: Create a print statement for every field in the struct.
    // .map() iterates over the fields and creates a list of code blocks.
    // Syntax: Trailing Lambda with 'fn:' shorthand. No parentheses.
    let print_statements = def.fields.map fn: quote {
        // 'quote' creates a piece of code. 
        // We inject 'a.name' and 'self.a.name' into this code.
        println("Value of " + a.name + " is: " + self.a.name)
    }

    let name = def.name

    // Return the final code block
    // We inject the list of print_statements into the function body.
    quote {
        impl name {
            fn describe(&self) {
                print_statements // Automatic insertion of the list
            }
        }
    }
}

// Usage
// The 'with' keyword triggers the macro.
struct User with Describe {
    name: String,
    age: i32
}

fn main() {
    // Implicit Anonymous Constructor via strict Subject/Config protocol.
    let u = User("Alice", 30)
    u.describe() // This function was generated by the macro!
}
```

### 10.4. Hygiene and Scope Injection
By default, Nikaia macros are **Hygienic**. This means a variable defined inside a macro (like `let temp = 0`) is invisible to your main code. This prevents accidental conflicts where a macro overwrites your variables.

**Breaking Hygiene (Injection)**
Sometimes, you *want* a macro to create a variable that the user can use (e.g., a loop macro providing an `index` variable). To do this, you must mark the variable name as "injected" using the `@` prefix inside the quote.

```nika
pub macro CreateVar(name_str: String) -> AstExpr {
    let var_name = Ident::new(name_str)
    
    quote {
        // The '@' tells the compiler: "Inject this name into the user's scope"
        let @var_name = 100
    }
}

fn main() {
    CreateVar("score")
    println(score) // Works! Prints 100.
}
```

### 10.5. Using DSLs (The `dsl` Keyword)
While `quote` allows generating code, the `dsl` keyword allows developers to embed *foreign syntax* directly into Nikaia code. This is useful for SQL, HTML, or Regex.

The syntax `dsl <macro_name> <context> { ... }` passes the raw tokens inside the block to the macro, allowing completely custom syntax.

**Example: Embedding SQL**
Instead of writing SQL as a string (which is prone to typos), we verify it at compile time.

```nika
use nikaia_sql::{Database, sql}

fn query_users(db: Shared[Database], min_age: i32) {
    // The code inside { ... } is NOT Nikaia syntax.
    // It is raw SQL, processed by the 'sql' macro.
    // The macro validates table names and column types during compilation.
    let users = dsl sql db {
        SELECT name, email 
        FROM users 
        WHERE age >= min_age
    }
}
```

### 10.6. Advanced Parser Features
Nikaia grammars are designed for high-performance tooling.

**Zero-Copy Parsing (Slices)**
Traditional parsers often copy text into new `String` objects for every identifier found. Nikaia avoids this.
The parser yields **Slices** (references to the original text buffer). The compiler's borrow checker ensures that you cannot use a token after the original text has been deleted. This significantly reduces memory usage.

**Fault Tolerance (Recovery)**
When building tools like Language Servers (LSP), the parser must not crash on the first error. It needs to recover and continue parsing the rest of the file.
Nikaia supports `recover` blocks to define synchronization points.

```nika
rule block -> Vec[Stmt] = {
    "{" statements:stmt()* "}"
}
// If parsing fails inside the block, the parser skips tokens 
// until it finds a closing brace '}', then resumes.
recover { "}" }
```

---

## Chapter 11: Nikaia Advanced Profile (The Compute Engine)

While **Nikaia Lite** is designed for I/O density, **Nikaia Advanced** (`--profile=advanced`) is designed for **Parallel CPU Throughput**.

### 11.1. Implicit Async & The Scheduler
In both profiles, the syntax looks identical. You do **not** use `async` keywords on function definitions.
* **Lite:** Functions yield on I/O events (Cooperative).
* **Advanced:** The runtime uses a **Work-Stealing Scheduler**. It automatically distributes tasks across all CPU cores.

The code remains "Direct Style". You write code as if it were synchronous, and the compiler handles the suspension points.

### 11.2. Parallelism via `spawn`
Since code is implicitly async, "calling a function" usually means "running it now". To run tasks in **Parallel**, you strictly use `spawn`.

In the Advanced Profile, `spawn` returns a **Handle**. This handle allows you to wait for the result later (`join`).

**Implicit Move (Ownership Transfer)**
In Nikaia, spawning a task **always** implies transferring ownership of captured variables to the new task. There is no explicit `move` keyword required.
* **Why?** This guarantees thread safety by default. The parent thread cannot access the data while the child is using it (Use-After-Free prevention).
* **Copying:** If you need to keep the data in the parent thread, you must explicitly call `.clone()` before spawning.

```nika
fn process_image(path: String) -> Image { ... }

fn main() {
    // 1. Sequential Execution (Default)
    // The main thread runs image1, then image2.
    let img1 = process_image("a.jpg") 
    let img2 = process_image("b.jpg")

    // 2. Parallel Execution (Fork)
    // 'spawn' throws the task into the Thread Pool.
    // Trailing lambda syntax: no parentheses around 'fn:'.
    // CRITICAL: arguments are IMPLICITLY moved into the task.
    let handle1 = spawn fn: process_image("a.jpg")
    let handle2 = spawn fn: process_image("b.jpg")

    // 3. Join (Await) with Fault Isolation
    // If a task crashes, it does NOT kill the program.
    // 'join' returns an Error which we handle with 'catch'.
    let result1 = handle1.join() catch { 
        println("Task 1 crashed!"); return 
    }
    let result2 = handle2.join() catch {
        println("Task 2 crashed!"); return
    }
}
```

---

## Chapter 12: Thread Safety and Synchronization

Because the Advanced Profile runs code on multiple physical CPU cores simultaneously, strict safety rules apply to prevent data corruption.

### 12.1. The `sync` Keyword (CPU Constraints)
Since everything in Nikaia is "Async by Default" (interruptible), we need a way to define code that **must not be interrupted** or moved between threads mid-execution.

The `sync` keyword allows you to mark a function as a **pure CPU task**.
* **Constraint:** A `sync` function can **only** call other `sync` functions.
* **Prohibition:** It cannot call standard functions (which might perform I/O).

This effectively creates two worlds: the flexible **Async World** (Default) and the strict **Sync World** (Computation).

```nika
// 'sync' guarantees: I will never pause, I will never do I/O.
fn calculate_physics(obj: Object) sync {
    obj.x += obj.velocity 
    // fs::read("log.txt") // Compiler Error: Forbidden I/O in sync context
}

// Usage in Parallel Iterator
// par_iter requires a 'sync' closure because it runs purely on CPU cores.
// Trailing lambda syntax: 'fn:' is outside parentheses.
particles.par_iter().for_each fn: calculate_physics(a)
```

### 12.2. The Dual Nature of `Locked[T]`
To share mutable data, you use the `Locked[T]` type. Its implementation changes entirely based on the profile, providing "Zero Cost Abstraction" relative to the requirements.

**In Nikaia Lite:**
* **Implementation:** Similar to a `RefCell` with a reentrancy check.
* **Cost:** Extremely cheap (integer increment).
* **Purpose:** It protects against **Logical Deadlocks** (e.g., Task A locks data, waits for network, Task B tries to lock same data -> Panic!). It does not use OS primitives.

**In Nikaia Advanced:**
* **Implementation:** A real OS-level **Mutex** (Mutual Exclusion).
* **Cost:** Higher (Atomic operations).
* **Purpose:** It protects against **Memory Corruption**. It ensures that two physical threads cannot write to the memory address at the same time.

**Deadlock Prevention (I/O Rule)**
Because `Locked` in Advanced mode blocks the thread, holding a lock for too long is dangerous.
**Rule:** You cannot perform I/O (call non-sync functions) while holding a lock. This prevents "Sleeping while holding a lock."

### 12.3. Deadlock Prevention: Atomic Composition
The classic cause of deadlocks is inconsistent locking order (Thread 1 locks A then B; Thread 2 locks B then A).
In Nikaia, trying to nest locks manually is considered an anti-pattern and often a compile-time error.

**The Solution: `access_all`**
Instead of nesting `access` calls, Nikaia provides `access_all` to request multiple resources simultaneously.

* **Mechanism:** The runtime sorts the resources by their memory address (or internal ID) before locking. This guarantees a globally consistent locking order across all threads.
* **Safety:** It is mathematically impossible to create a deadlock cycle between A and B if everyone uses `access_all(A, B)`, because everyone will implicitly lock "Lower Address first, Higher Address second".

```nika
let account_a: Shared[Locked[Account]] = ...
let account_b: Shared[Locked[Account]] = ...

// ERROR: Manual Nesting is forbidden to prevent Deadlocks.
// account_a.access fn: ...

// Atomic Locking (Deadlock Proof)
// The runtime sorts A and B internally and locks them safely.
// We use a trailing lambda block explicitly here.
access_all(account_a, account_b) fn(a, b) {
    // Both 'a' and 'b' are mutable guards here.
    let amount = 100
    a.balance -= amount
    b.balance += amount
}
```

### 12.4. Racing Tasks (`select`)
Sometimes you want to run multiple tasks, but only care about the one that finishes *first*.

```nika
select {
    // Case 1: Computation finishes first
    result = heavy_math() => { return result }
    
    // Case 2: Timeout happens first
    _ = sleep(5.seconds()) => { throw TimeoutError("Too slow!") }
}
```
*Note: When one branch wins, the other task is automatically cancelled and cleaned up.*

### 12.5. Channels (Message Passing)
Instead of locking shared memory, Nikaia encourages **Message Passing**.

```nika
// Subject: 100 (capacity)
let (tx, rx) = channel::bounded(100)

// Implicit Move transfers 'tx' into the background task
spawn fn {
    tx.send("Calculation complete")
}

let msg = rx.recv() // Waits (non-blocking yield) for the message
```

### 12.6. Data Parallelism (`par_iter`)
If you have a large list of data and want to process it using all CPU cores, use `par_iter` (Parallel Iterator).

```nika
let pixels = [/* 1 million pixels */]

// The compiler splits the array into chunks and distributes them
// across all cores. The closure must be 'sync'.
// Correct Syntax: Methods chained with trailing lambdas (no parens around fn:).
let bright_pixels = pixels.par_iter()
    .map fn: a.brightness * 1.5
    .filter fn: a > 0.5
    .collect()
```

### 12.7. Scoped Threads
Normally, threads cannot borrow variables from the stack because the compiler doesn't know when the thread will finish. **Scoped Threads** guarantee that the threads finish *before* the current function ends, allowing safe borrowing.

```nika
let data = [1, 2, 3]

// Syntax: Block Lambda with explicit argument 's' (the scope)
// Trailing lambda syntax allows omitting parentheses for the block.
thread::scope fn(s) {
    // This thread borrows 'data' directly. No copy needed.
    s.spawn fn: println("Reading: {data}")

    // The scope waits here until the thread is done.
}
```

### 12.8. Supervision Trees
In complex systems, threads might crash (panic). A **Supervisor** monitors tasks. If a child task crashes, the supervisor can decide to:
* **Restart** the task.
* **Crash** the parent (escalate).
* **Ignore** the error.

This allows building self-healing systems.

```nika
// Subject: The Task (Lambda)
// Config: restart_policy (Protocol: separated by ;)
// Note: 'spawn' syntax (fn {}) is the subject.
supervisor::start_link(fn {
    server.run()
}; restart_policy: "always")
```
