# Architecture Decision Record (ADR) 002: Multi-Language Compiler Toolchain via `rustc`-Bridge and Cargo Orchestration

**Date:** 2026-01-18
**Status:** Accepted (Supersedes ADR 001)
**Context:** Development of a modular, multi-language compiler toolchain, utilizing the "Nikaia" language as the reference implementation. The objective is to combine the declarative ergonomics of custom frontends with the type safety, borrow checking, and advanced code generation capabilities (Cranelift/LLVM) of the Rust toolchain, while entirely bypassing the severe compilation bottlenecks associated with traditional Rust procedural macros.

---

## 1. Architectural Decision

The toolchain architecture is strictly decoupled into five distinct phases (0 through 4). Instead of utilizing `rustc` as a black-box command-line interface, the toolchain acts as a Cargo workspace wrapper and programmatically hijacks the internal Rust compiler APIs (`rustc_driver`, `rustc_interface`) to inject a sanitized Abstract Syntax Tree (AST).



### Phase 0: Orchestration & Cargo Instrumentation (The CLI Wrapper)
To maintain native interoperability with the Rust ecosystem (crates.io) while enforcing a custom project structure, the `nikaia` CLI wraps and instruments `cargo`.
* **Manifest Translation:** The CLI reads `nikaia.toml` and dynamically generates a compliant `Cargo.toml`, seamlessly passing through native Rust dependencies (e.g., `regex = { type = "rust", version = "1.5" }`).
* **Interception via `RUSTC_WORKSPACE_WRAPPER`:** The CLI injects this environment variable to intercept compilation. Standard Rust crates are passed through to the native `rustc`. When local `.nika` source files are targeted, the wrapper halts the pass-through and triggers the custom 4-Phase Pipeline.
* **Compile-Time Caching:** The `nikaia.lock` file acts as a deterministic cache key. If a macro performs Compile-Time I/O (e.g., reading an external file), the file's SHA256 hash is recorded. Subsequent builds bypass macro evaluation if the hash remains unchanged, ensuring instant builds.
* **Profile Management:** The wrapper controls compilation targets by injecting `opt-level` and `panic` strategies based on the selected build profile ("lite" for size/I/O, "advanced" for throughput/LTO).

### Phase 1: Frontend (Lexing, Parsing & CST Generation)
* **Technology:** `winnow-grammar` (powered by the `syn-grammar-model` frontend).
* **Mechanism:** Source code is parsed directly into a Concrete Syntax Tree (CST).
* **Input Tracking:** The parser strictly consumes `winnow::stream::LocatingSlice<&str>` to track exact byte offsets for every parsed token.
* **Output:** A raw AST that preserves unresolved compile-time directives and metaprogramming constructs.

### Phase 2: Compile-Time JIT-Interpreter (Macro Expansion)
This phase eliminates the need to compile macros as dynamic libraries, drastically reducing build times.
* **Technology:** Internal AST-Walker and in-memory Lightweight VM.
* **Mechanism:** The compiler evaluates metaprogramming nodes on the fly:
  * **Quasi-Quoting (`quote { ... }`):** Generates new AST nodes and injects scope variables hygienically (or unhygienically via `@`).
  * **DSL Embedding (`dsl <macro> { ... }`):** Passes raw token streams to JIT macros for validation (e.g., SQL syntax checks) and AST replacement.
  * **Static Parsing:** Executes `from "file" with Parser` directives by loading external files and running the generated grammars during the build process.
* **Output:** A fully desugared, macro-free High-Level Intermediate Representation (HIR) AST.

### Phase 3: The `rustc`-Bridge (AST Lowering & Semantic Mapping)
* **Technology:** `parser-rustc-bridge` (linking against `rustc_driver`, `rustc_interface`, `rustc_span`).
* **Query Hijacking:** The bridge utilizes `override_queries` within `rustc_interface::Config` to bypass Rust's native parsing phase, directly providing a manually constructed `rustc_ast::ast::Crate` in memory.
* **Semantic Translation:** Language-specific semantics are lowered into Rust primitives:
  * Profile-dependent memory models map `Shared[Locked[T]]` to either `Rc<RefCell<T>>` (Lite) or `Arc<Mutex<T>>` (Advanced).
  * Contextual captures (e.g., `@detached fn` for `spawn`) are lowered into `rustc_ast::ExprKind::Closure` utilizing capture-by-value (`move ||`) semantics to ensure thread safety.
* **Span Mapping:** Byte offsets from Phase 1 are translated via the `SourceMap` into global `rustc_span::Span` coordinates, ensuring Rust's diagnostic engine maps errors precisely to the original source code.

### Phase 4: Backend (Verification & Code Generation)
Upon successful AST injection, the bridge returns `Compilation::Continue` to the `rustc_driver`.
* **Verification:** The Rust compiler lowers the injected AST to HIR/MIR. The Borrow Checker natively verifies memory and thread safety (e.g., preventing `!Send` types from crossing thread boundaries in the Advanced profile).
* **Code Generation:**
  * `nikaia build` utilizes `-Z codegen-backend=cranelift` for sub-second development iterations.
  * `nikaia build --profile=advanced` leverages LLVM with Link Time Optimization (LTO) for maximum CPU throughput.

---

## 2. Consequences

### Advantages
* **Zero-Overhead Metaprogramming:** Executing macros within the JIT interpreter completely bypasses the compilation latency of `proc-macro` crates.
* **Native Rust Interoperability:** Cargo instrumentation allows seamless consumption of crates.io dependencies without reinventing dependency resolution or linking logic.
* **Enterprise-Grade Diagnostics:** Translating spans directly into `rustc_span` yields highly precise, native Rust compiler error messages and immediate Language Server Protocol (LSP) compatibility for free.
* **Guaranteed Memory Safety:** Relying on the Rust Borrow Checker prevents logical data races and use-after-free conditions in multi-threaded contexts.

### Risks and Mitigations
* **Toolchain Pinning:** Linking against `rustc_private` necessitates strictly pinning the compiler to a specific nightly release. Version upgrades will require manual auditing of Layer 3 structures.
* **AST Rigidity:** The `rustc_ast` requires flawless structural integrity. Invalid spans or `NodeId` sequences will result in Internal Compiler Errors (ICE). A strict validation pass prior to injection is mandatory.
* **Language Constraints:** Target languages processed by this backend must possess semantics compatible with Rust's ownership and lifetime model. Dynamic languages relying on pervasive garbage collection cannot optimally leverage this architecture.
