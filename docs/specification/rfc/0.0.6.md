RFC 0.0.6 â€“ Grammar Protocol, Scannerless Parsing & Typed Bindings
Status: Request for Comment (RFC)
Target Version: Nikaia 0.0.6
Date: January 24, 2026
1. Executive Summary
This RFC formalizes the transition of Nikaia from a monolithic compiler to a modular Language-Host Architecture.
It replaces the hardcoded system features and string-based interpolation of Version 0.0.5 with a Scannerless Grammar Protocol. DSLs are treated as first-class expressions (let x = dsl ...) that define their own parsing logic, termination rules, and binding strategies.
Key Architectural Pivot:
The compiler core abandons the concept of a global Lexer/Token-Stream. Instead, parsing control is delegated directly to generated, domain-specific parsers. This enables Nikaia to host conflicting syntaxes (SQL, ASM, JSON) without ambiguity while maintaining zero-copy performance.
2. Analysis of Status Quo (Version 0.0.5)
The architecture of Version 0.0.5 is deprecated due to three fundamental design flaws:
2.1 The Architecture Conflict (WASM Incompatibility)
v0.0.5 embedded unsafe asm with register constraints (in("eax")) directly into the language core.
 * Flaw: This coupled the core language to register-based CPUs, rendering it incompatible with Stack Machines like WebAssembly (WASM).
 * Resolution: Hardware instructions are moved to library-defined DSLs (dsl backend::x86 vs dsl backend::wasm).
2.2 The Parsing Conflict (Tokenization Limits)
v0.0.5 relied on a global Lexer and string interpolation {var}.
 * Flaw: A global lexer cannot correctly tokenize embedded languages that use conflicting delimiters (e.g., JSON }, Rust lifetimes 'a).
 * Resolution: Adoption of a Scannerless Parsing Model. The core delegates the raw byte cursor to the DSL, allowing the DSL to handle its own lexical structure.
2.3 The Binding Conflict (Stale Closures)
Previous drafts utilized pure "Scope Binding" for all DSLs.
 * Flaw: While perfect for Assembly, this is fatal for SQL Prepared Statements as it bakes variable values into the statement definition, preventing reuse.
 * Resolution: Introduction of Hybrid Binding. The protocol supports both Immediate Captures (compile-time/scope) and Deferred Parameters (runtime).
3. The Grammar Protocol (Scannerless Architecture)
Nikaia 0.0.6 utilizes a Scannerless, Self-Hosted Parser Architecture.
3.1 The Handoff Mechanism
 * Trigger: The Core Parser recognizes dsl <Grammar> {.
 * Boundary Scan: The Core Parser scans ahead for the explicit termination sequence } eod.
 * Parallelism: By identifying the block boundary (} eod) upfront, the Core Parser can skip the DSL body and continue parsing the rest of the file in parallel, without waiting for the DSL parser to complete.
 * Delegation: The Core passes the isolated byte slice (content between { and } eod) to the specific Grammar implementation.
3.2 Scannerless Grammar Definition 2.0
To support efficient parsing of complex languages without a lexer, the Grammar syntax is upgraded to support Commit Points (=>) and Auto-AST.
 * Commit Points (=>): Controls backtracking. Once the left side matches, the parser commits to this branch. If subsequent parts fail, the parser aborts with an error instead of trying other alternatives.
 * Regex Terminals: regex("...") generates efficient DFAs for token matching on the byte stream.
 * Auto-AST: If no explicit mapping (->) is provided, Nikaia automatically generates Structs (for labeled sequences) and Enums (for alternatives).
<!-- end list -->
grammar Json {
    // Auto-AST: Generates 'enum Value { Object(Object), Array(Array), ... }'
    pub rule value = object | array | string | number
    
    // Commit Point usage: If '{' is found, we MUST parse members and '}', otherwise Error.
    rule object -> Object 
        = "{" => members:list(pair, ",") "}" 
        -> { Object { members } }

    rule pair = key:string ":" => val:value
}

4. Syntax Specification (Expressions)
DSLs are expressions that return a typed value.
> let <Result> = dsl <Grammar> [ from <Source> | { <Body> } eod ]
> 
 * Grammar: The parser definition (e.g., mysql, toml).
 * Result: A Specialized Shadow Type. It is not just the AST, but a type carrying the signature of the found parameters (see Section 5.3).
 * } eod: The explicit End-Of-DSL marker required for parallel parsing.
5. The Hybrid Binding & Execution Protocol
This section defines how DSLs interact with Nikaia's variables and functions. The protocol bridges the gap between the raw text of the DSL and the type-safe execution in the host language.
5.1 Binding Primitives (Grammar Side)
Inside a Grammar mapping (-> {}), authors use compiler intrinsics to define holes in the AST.
 * Immediate Capture (meta::capture(id)): Resolves a variable from the surrounding scope at compile-time (e.g., $table).
 * Deferred Parameter (meta::parameter(name, type)): Defines a named runtime parameter (e.g., :id).
<!-- end list -->
rule parameter = ":" => id:ident 
    -> { meta::parameter(id, "infer") }

5.2 Shadow Types (Compiler Side)
When a DSL block containing meta::parameter is parsed, the compiler generates a unique Shadow Type. This type acts as a template instance.
 * Example: dsl mysql { ... :id ... :active } eod
 * Generated Type: SqlAst<Signature={id: i32, active: bool}>
5.3 Typed Dynamic Binding (impl Side)
Library authors implement methods on the Grammar type. To accept the dynamic parameters defined by the DSL, they use the Typed Spread Operator (...: Self::dsl).
Crucially, Nikaia's Subject ; Config protocol is enforced: DSL parameters are always treated as Configuration (Named Arguments).
Syntax:
> pub fn name(self; ...identifier: Self::dsl)
> 
 * ...: Signals variable named arguments.
 * identifier: The name of the struct containing the values inside the function.
 * Self::dsl: The type constraint proving these arguments belong to this Grammar.
Implementation Example:
impl SqlParser {
    // Subject: self (The AST)
    // Config: ...args (The DSL parameters)
    pub fn execute(self; ...args: Self::dsl) -> Result<Row> {
        // 'args' is a specialized struct.
        // We access values genericaly via .values() (Order matches AST)
        let param_list = args.values(); 
        return self.conn.query(self.sql, param_list);
    }
}

5.4 Usage (User Side)
The user invokes the method. The compiler enforces that all parameters found in the DSL string are provided as Named Arguments in the Configuration block (after ;).
let stm = dsl mysql { 
    SELECT * FROM users WHERE id = :target_id 
} eod

// Compiler generates specialized code connecting 'target_id' to 'args'
stm.execute(; target_id: 501)

6. Implementation Strategy
To ensure Nikaia remains a high-performance systems language:
 * Monomorphization: The compiler generates specialized machine code for every unique DSL string and execute call. The args struct is allocated on the stack (Zero-Allocation).
 * Scannerless Optimization: Grammars are compiled to direct byte-stream consumers, avoiding intermediate token streams.
 * Context-Aware SIMD: Parsers utilize SIMD instructions optimized for the specific embedded syntax context.
7. Conclusion
RFC 0.0.6 resolves the structural limitations of Version 0.0.5. By moving to a Scannerless Grammar Protocol, Nikaia solves the "Lexer Boundary" problem without brittle delimiters. By adopting Hybrid Binding with Typed Dynamic Dispatch, it unifies high-performance Assembly generation with reusable, type-safe SQL Prepared Statements. The introduction of Subject ; Config semantics for DSL parameters (fn name(self; ...args)) ensures consistency with the core language philosophy.
