grammar Core {
    // --- Entry Point ---
    // Ein Programm ist eine Liste von Items.
    pub rule program -> Program = { 
        items:item()* } -> { 
        Program { items } 
    }

    // --- Top-Level Items ---
    // Hier nutzen wir Alternatives (|), um später Structs/Enums einfach anzuhängen.
    rule item -> Item =
        | fn_item()

    // Die Funktions-Definition.
    // Wir erzwingen die volle Signatur gemäß Spec, auch wenn Teile (Generics) optional sind.
    // Syntax: fn name[T](args) sync -> Ret { ... }
    rule fn_item -> Item = {
        "fn" 
        name:ident() 
        generics:generic_list()?   // Platzhalter für [T]
        args:fn_arg_list() 
        is_sync:"sync"?            // Spec Part II: sync modifier
        ret:return_type_arrow()?   // -> Type
        body:block()
    } -> {
        Item::Fn {
            name,
            generics: generics.unwrap_or_default(),
            args,
            ret_type: ret,
            body,
            is_sync: is_sync.is_some()
        }
    }

    // --- Argumente & Typen ---
    
    // (a: i32, b: T)
    rule fn_arg_list -> Vec<FnArg> = {
        "(" args:fn_arg_def()*, ")" // Komma-Handling macht unser Generator via '*'
    } -> { args }

    rule fn_arg_def -> FnArg = {
        name:ident() ":" ty:type_ref()
    } -> { FnArg { name, ty } }

    // -> Type
    rule return_type_arrow -> Type = {
        "->" ty:type_ref()
    } -> { ty }

    // Generics [T] - Aktuell parsen wir es, ignorieren aber den Inhalt im AST oft noch
    rule generic_list -> Vec<GenericParam> = {
        "[" params:generic_param()*, "]"
    } -> { params }

    rule generic_param -> GenericParam = {
        name:ident() 
        // Hier würden später Trait Bounds kommen: : Debug
    } -> { GenericParam { name } }

    // Ein Typ: String oder List[i32]
    rule type_ref -> Type = {
        name:ident() 
        generics:generic_type_args()?
    } -> { 
        Type { name, generics: generics.unwrap_or_default() } 
    }
    
    // [i32, String] für Typen
    rule generic_type_args -> Vec<Type> = {
        "[" args:type_ref()*, "]"
    } -> { args }

    // --- Statements & Blocks ---

    rule block -> Block = {
        "{" stmts:stmt()* "}"
    } -> { Block { stmts } }

    rule stmt -> Stmt =
        | let_stmt()
        | expr_stmt()

    // let mut x: i32 = ...
    rule let_stmt -> Stmt = {
        "let" 
        mutable:"mut"? 
        name:ident() 
        ty:type_annotation()? 
        "=" 
        val:expr() 
        ";"? // Semikolon optional (Parser-Generator Logic)
    } -> {
        Stmt::Let {
            name,
            mutable: mutable.is_some(),
            ty,
            value: val
        }
    }

    rule type_annotation -> Type = {
        ":" ty:type_ref()
    } -> { ty }

    // Expression Statement (Funktionsaufruf etc.)
    rule expr_stmt -> Stmt = {
        e:expr() ";"?
    } -> { Stmt::Expr(e) }

    // --- Expressions (Das "Hello World" Minimum) ---
    
    // Wir unterstützen hier Calls und Literale.
    // Call-Syntax: name(args)
    rule expr -> Expr =
        | call_expr()
        | str_lit()
        // Später hier: | bin_op() | if_expr()

    rule call_expr -> Expr = {
        func:ident() "(" args:expr_list() ")"
    } -> {
        // Im AST ist 'func' eine Box<Expr>, meistens Expr::Variable
        Expr::Call {
            func: Box::new(Expr::Variable(func)),
            args
        }
    }

    rule expr_list -> Vec<Expr> = {
        args:expr()*, 
    } -> { args }

    rule str_lit -> Expr = {
        s:string_lit() // 'string_lit' ist ein Built-in unseres Generators (Mapped auf syn::LitStr)
    } -> {
        Expr::LitStr(s)
    }
}

